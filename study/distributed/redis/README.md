### Redis分布式缓存

#### 集群模式
- 主从模式
    > 支持主从复制，可以进行读写分离
    > 主从服务器宕机都会导致部分服务请求失败，需手动重启机器或切换服务器IP才能恢复

- Sentinel哨兵模式
    > 在主从的基础上，增加哨兵来监控主从服务器状态。当主服务器发生故障时，自动进行主从切换，提高系统健壮性和可用性。
    > 但仍然只有一个主节点，不能缓解写压力

- Redis Cluster
    > 哨兵模式虽然实现了高可用和读写分离，但每台Redis服务器都存储相同的数据，很浪费资源。
    > Redis Cluster模式实现了分布式存储，每台Redis服务器上存储不同的内容
    > 为了保证高可用，redis-cluster集群引入了主从模式，当主节点发生故障，会自动切换到从节点
    > redis-cluster使用数据分片算法(sharding)，Redis集群有16384个插槽`slot`，每个主节点负责其中的一部分。
    > key路由算法 `HASH_SLOT = CRC16(key) mod 16384`


#### 过期策略：

- 定期删除
    > 定期删除：每隔一段时间如100ms，随机抽取一些设置了过期时间的key，检查其是否过期，如果过期则删除

- 惰性删除
    > 惰性删除：在获取某个key时候，redis会检查过期，如果过期则删除，不返回任何内容
    > 如果有大量过期key，没有被查询惰性删除，也没有被抽取定期删除，导致redis内存预警，就需要走内存淘汰机制

#### 内存淘汰机制：
- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key 
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除


#### 缓存穿透、击穿、雪崩

##### 缓存穿透
> 查询缓存和数据库中都不存在的数据，比如id<0或者id很大的数据。此时缓存不命中，会直接穿透到数据库层查询
>
> 解决方案：

- 空缓存
- 布隆过滤器

#### 缓存击穿

> 在同一时间高并发访问同一个key，而此时key失效，导致大量请求到达数据库层
>
> 解决方案：

- 热点key永不过期
- Redis Zookeeper等 互斥锁

#### 缓存雪崩

> 大量缓存数据过期，导致大量请求落到数据库，造成数据库压力过大甚至宕机
>
> 解决方案：

- 分散缓存数据的过期时间，避免大量key同时失效
- 并发控制、集群部署



